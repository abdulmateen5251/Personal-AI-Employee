from __future__ import annotations

from datetime import datetime, timedelta, timezone
import json
import os
from pathlib import Path
import sys
import time

ROOT = Path(__file__).resolve().parents[4]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from src.core.audit_logic import SUBSCRIPTION_PATTERNS
from src.core.audit_logger import log_action
from src.core.config import get_vault_path

PID_FILE = Path("/tmp/ceo-briefing.pid")
STATE_FILE = ".ceo-briefing-state.json"
CHECK_INTERVAL = 3600


def _load_state(vault: Path) -> dict:
    p = vault / "Logs" / STATE_FILE
    if p.exists():
        return json.loads(p.read_text())
    return {"last_week_generated": ""}


def _save_state(vault: Path, state: dict) -> None:
    p = vault / "Logs" / STATE_FILE
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(json.dumps(state, indent=2))


def _done_items_last_week(vault: Path) -> list[Path]:
    done = vault / "Done"
    if not done.exists():
        return []
    cutoff = datetime.now(timezone.utc) - timedelta(days=7)
    rows: list[Path] = []
    for f in done.glob("*"):
        if f.is_file():
            mtime = datetime.fromtimestamp(f.stat().st_mtime, timezone.utc)
            if mtime >= cutoff:
                rows.append(f)
    return sorted(rows, key=lambda x: x.stat().st_mtime, reverse=True)


def _find_subscription_signals(vault: Path) -> list[str]:
    signals: list[str] = []
    accounting = vault / "Accounting"
    if not accounting.exists():
        return signals
    for csv_file in accounting.rglob("*.csv"):
        text = csv_file.read_text(encoding="utf-8", errors="ignore").lower()
        for pattern, name in SUBSCRIPTION_PATTERNS.items():
            if pattern in text:
                signals.append(name)
    return sorted(set(signals))


def generate_weekly_briefing(vault: Path) -> Path:
    briefings = vault / "Briefings"
    briefings.mkdir(parents=True, exist_ok=True)

    now = datetime.now(timezone.utc)
    done_items = _done_items_last_week(vault)
    subscriptions = _find_subscription_signals(vault)

    completed_lines = "\n".join([f"- [x] {f.name}" for f in done_items[:12]]) or "- [ ] No completed tasks detected"
    subscription_lines = "\n".join([f"- {s}: detected in accounting inputs" for s in subscriptions]) or "- No subscription signal detected this week"

    out = briefings / f"{now.strftime('%Y-%m-%d')}_Monday_Briefing.md"
    out.write_text(
        f"""---
generated: {now.isoformat()}
period: last 7 days
---

# Monday Morning CEO Briefing

## Executive Summary
Operational flow is active. Weekly snapshot generated automatically.

## Revenue
- This Week: Review required from accounting system
- MTD: Review required from accounting system
- Trend: Monitoring

## Completed Tasks
{completed_lines}

## Bottlenecks
- Check `/Pending_Approval` for stalled high-priority actions.
- Review tasks that remained in `/Needs_Action` for over 24 hours.

## Proactive Suggestions
### Cost Optimization
{subscription_lines}

### Upcoming Focus
- Resolve pending approvals daily.
- Keep social cadence active (LinkedIn + Facebook + Instagram + X drafts).

---
*Generated by AI Employee Gold Tier*
"""
    )

    log_action(
        action_type="ceo_briefing_generated",
        target=out.name,
        parameters={"done_count": len(done_items), "subscription_signals": subscriptions},
        result="success",
    )
    return out


def _week_key() -> str:
    now = datetime.now(timezone.utc)
    iso = now.isocalendar()
    return f"{iso.year}-W{iso.week}"


def main() -> None:
    vault = get_vault_path()
    PID_FILE.write_text(str(os.getpid()))

    while True:
        try:
            state = _load_state(vault)
            key = _week_key()
            if state.get("last_week_generated") != key and datetime.now().weekday() == 0:
                output = generate_weekly_briefing(vault)
                state["last_week_generated"] = key
                _save_state(vault, state)
                log_action(
                    action_type="ceo_briefing_scheduler",
                    target=output.name,
                    parameters={"week": key},
                    result="generated",
                )
        except Exception as exc:
            log_action(
                action_type="ceo_briefing_scheduler",
                target="weekly",
                parameters={},
                result=f"error: {exc}",
            )
        time.sleep(CHECK_INTERVAL)


if __name__ == "__main__":
    main()
